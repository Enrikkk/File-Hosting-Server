package es.um.redes.nanoFiles.tcp.message;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;

import javax.management.RuntimeErrorException;

import es.um.redes.nanoFiles.util.FileInfo;

public class PeerMessage {

	// Nuevo
	public static final byte HASH_LENGTH = 40;
	private byte opcode;

	/*
	 * TODO: (Boletín MensajesBinarios) Añadir atributos u otros constructores
	 * específicos para crear mensajes con otros campos, según sea necesario
	 * 
	 */

	private long fileSize;
	
	private int chunkSize;
	
	private String fileHash;
	
	private byte longFileName;
	
	private String fileName;
	
	private byte[] contenido;
	
	private long fileOffset;
	

	public PeerMessage() {
		this.opcode = PeerMessageOps.OPCODE_INVALID_CODE;
	}
	
	public PeerMessage(byte op) {
		this.opcode = op;
	}
	
	public PeerMessage(byte op, long fileSize, String fileHash) {
		this.opcode = op;
		this.fileSize = fileSize;
		this.fileHash = new String(fileHash);
	}
	
	public PeerMessage(byte op, byte longFileName, String fileName) {
		this.opcode = op;
		this.longFileName = longFileName;
		this.fileName = new String(fileName);
	}
	
	/*
	 * TODO: (Boletín MensajesBinarios) Crear métodos getter y setter para obtener
	 * los valores de los atributos de un mensaje. Se aconseja incluir código que
	 * compruebe que no se modifica/obtiene el valor de un campo (atributo) que no
	 * esté definido para el tipo de mensaje dado por "operation".
	 */
	public byte getOpcode() {
		return opcode;
	}

	public long getFileSize() {
		return fileSize;
	}
	
	public byte[] getContenido() {
		return contenido;
	}
	
	public String getFileHash() {
		return fileHash;
	}
	
	public byte getLongFileName() {
		return longFileName;
	}
	
	public void setFileSize (long sizeOfFile) {
		if (opcode != PeerMessageOps.OPCODE_FILE_METADATA && opcode != PeerMessageOps.OPCODE_UPLOAD_FILE) {
			throw new RuntimeException("PeerMessage: setFileSize called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.fileSize = sizeOfFile;
	}

	public void setFileHash (String hashOfFile) {
		if (opcode != PeerMessageOps.OPCODE_FILE_METADATA && opcode != PeerMessageOps.OPCODE_GET_CHUNK
				&& opcode != PeerMessageOps.OPCODE_UPLOAD_FILE) {
			throw new RuntimeException("PeerMessage: setFileSize called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.fileHash = new String (hashOfFile);
	}

	

	public void setLongFileName(byte longFileName) {
		if (opcode != PeerMessageOps.OPCODE_DOWNLOAD_FILE && opcode != PeerMessageOps.OPCODE_UPLOAD_FILE) {
			throw new RuntimeException("PeerMessage: setFileSize called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.longFileName = longFileName;
	}

	public String getFileName() {
		return fileName;
	}

	public void setFileName(String fileName) {
		if (opcode != PeerMessageOps.OPCODE_DOWNLOAD_FILE && opcode != PeerMessageOps.OPCODE_UPLOAD_FILE) {
			throw new RuntimeException("PeerMessage: setFileName called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.fileName = fileName;
	}
	
	public int getChunkSize() {
		return chunkSize;
	}
	
	public long getFileOffset() {
		return fileOffset;
	}
	
	public void setChunkSize(int chunkSize) {
		if (opcode != PeerMessageOps.OPCODE_GET_CHUNK && opcode != PeerMessageOps.OPCODE_RECEIVE_CHUNK
				&& opcode != PeerMessageOps.OPCODE_SEND_CHUNK) {
			throw new RuntimeException("PeerMessage: setChunkSize called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.chunkSize = chunkSize;
	}
	
	public void setFileOffset(long fileOffset) {
		if (opcode != PeerMessageOps.OPCODE_GET_CHUNK) {
			throw new RuntimeException("PeerMessage: setFileOffset called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.fileOffset = fileOffset;
	}
	
	public void setContenido(byte[] contenido) {
		if (opcode != PeerMessageOps.OPCODE_RECEIVE_CHUNK && opcode != PeerMessageOps.OPCODE_SEND_CHUNK) {
			throw new RuntimeException("PeerMessage: setContenido called for message of unexpected to " +
									PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
		this.contenido = contenido;
	}
	
	
	/**
	 * Método de clase para parsear los campos de un mensaje y construir el objeto
	 * DirMessage que contiene los datos del mensaje recibido
	 * 
	 * @param data El array de bytes recibido
	 * @return Un objeto de esta clase cuyos atributos contienen los datos del
	 *         mensaje recibido.
	 * @throws IOException
	 */
	public static PeerMessage readMessageFromInputStream(DataInputStream dis) throws IOException {
		/*
		 * TODO: (Boletín MensajesBinarios) En función del tipo de mensaje, leer del
		 * socket a través del "dis" el resto de campos para ir extrayendo con los
		 * valores y establecer los atributos del un objeto DirMessage que contendrá
		 * toda la información del mensaje, y que será devuelto como resultado. NOTA:
		 * Usar dis.readFully para leer un array de bytes, dis.readInt para leer un
		 * entero, etc.
		 */
		byte opcode = dis.readByte();
		PeerMessage message = new PeerMessage(opcode);
		switch (opcode) {
		case PeerMessageOps.OPCODE_AMBIGUOUS_NAME:
		case PeerMessageOps.OPCODE_FILE_NOT_FOUND: {
			break;
		}
		case PeerMessageOps.OPCODE_FILE_METADATA: {
			long sizeOfFile = dis.readLong();
			byte[] hashOfFile = new byte[HASH_LENGTH];
			dis.readFully(hashOfFile);
			message.setFileSize(sizeOfFile);
			message.setFileHash(new String(hashOfFile));
			break;
		}
		case PeerMessageOps.OPCODE_DOWNLOAD_FILE: {
			byte longOfFileName = dis.readByte();
			byte[] nameOfFile = new byte[longOfFileName];
			dis.readFully(nameOfFile);
			message.setLongFileName(longOfFileName);
			message.setFileName(new String(nameOfFile));
			break;
		}
		case PeerMessageOps.OPCODE_GET_CHUNK: {
			byte[] hashOfFile = new byte[HASH_LENGTH];
			dis.readFully(hashOfFile);
			message.setFileHash(new String(hashOfFile));
			message.setFileOffset(dis.readLong());
			message.setChunkSize(dis.readInt());
			break;
		}
		case PeerMessageOps.OPCODE_RECEIVE_CHUNK: {
			int chunkSize = dis.readInt();
			byte[] chunk = new byte[chunkSize];
			dis.readFully(chunk);
			message.setChunkSize(chunkSize);
			message.setContenido(chunk);
			break;
		}
		case PeerMessageOps.OPCODE_SEND_CHUNK: {
			int chunkSize = dis.readInt();
			byte[] chunk = new byte[chunkSize];
			dis.readFully(chunk);
			message.setChunkSize(chunkSize);
			message.setContenido(chunk);
			break;
		}
		case PeerMessageOps.OPCODE_UPLOAD_FILE:{
			byte longOfFileName = dis.readByte();
			byte[] nameOfFile = new byte[longOfFileName];
			dis.readFully(nameOfFile);
			message.setLongFileName(longOfFileName);
			message.setFileName(new String(nameOfFile));
			long sizeOfFile = dis.readLong();
			byte[] hashOfFile = new byte[HASH_LENGTH];
			dis.readFully(hashOfFile);
			message.setFileSize(sizeOfFile);
			message.setFileHash(new String(hashOfFile));
			break;
		}
		default:
			System.err.println("PeerMessage.readMessageFromInputStream doesn't know how to parse this message opcode: "
					+ opcode);
			System.exit(-1);
		}
		return message;
	}

	public void writeMessageToOutputStream(DataOutputStream dos) throws IOException {
		/*
		 * TODO (Boletín MensajesBinarios): Escribir los bytes en los que se codifica el
		 * mensaje en el socket a través del "dos", teniendo en cuenta opcode del
		 * mensaje del que se trata y los campos relevantes en cada caso. NOTA: Usar
		 * dos.write para leer un array de bytes, dos.writeInt para escribir un entero,
		 * etc.
		 */

		dos.writeByte(opcode);
		switch (opcode) {
		case PeerMessageOps.OPCODE_AMBIGUOUS_NAME:
		case PeerMessageOps.OPCODE_FILE_NOT_FOUND: {
			break;
		}
		case PeerMessageOps.OPCODE_FILE_METADATA: {
			dos.writeLong(fileSize);
			dos.write(fileHash.getBytes());
			break;
		}
		case PeerMessageOps.OPCODE_DOWNLOAD_FILE: {
			dos.writeByte(longFileName);
			dos.write(fileName.getBytes());
			break;
		}
		case PeerMessageOps.OPCODE_GET_CHUNK: {
			dos.write(fileHash.getBytes());
			dos.writeLong(fileOffset);
			dos.writeInt(chunkSize);
			break;
		}
		case PeerMessageOps.OPCODE_RECEIVE_CHUNK: {
			dos.writeInt(chunkSize);
			dos.write(contenido);
			break;
		}
		case PeerMessageOps.OPCODE_UPLOAD_FILE:{
			dos.writeByte(longFileName);
			dos.write(fileName.getBytes());
			dos.writeLong(fileSize);
			dos.write(fileHash.getBytes());
			break;
		}
		case PeerMessageOps.OPCODE_SEND_CHUNK: {
			dos.writeInt(chunkSize);
			dos.write(contenido);
			break;
		}
		default:
			System.err.println("PeerMessage.writeMessageToOutputStream found unexpected message opcode " + opcode + "("
					+ PeerMessageOps.opcodeToOperation(opcode) + ")");
		}
	}
}
