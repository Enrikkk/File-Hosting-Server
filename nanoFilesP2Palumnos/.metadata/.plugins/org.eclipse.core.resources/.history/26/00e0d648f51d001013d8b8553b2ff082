package es.um.redes.nanoFiles.tcp.client;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.LinkedList;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.ReentrantLock;

import es.um.redes.nanoFiles.util.FileInfo;

public class NFConnectorThread extends Thread{

	private Socket socket;
	private static Semaphore semaf;
	
	private RandomAccessFile fichero;
	private static long global_offset;
	private static long fichero_size;
	FileInfo respuestaFichero;
	NFConnector nf;
	String localFileName;
	
	synchronized long getOffset() {
		long offset =  global_offset;
		global_offset+=NFConnector.MAX_CHUNK_SIZE;
		return offset;
	}
	
	synchronized void writeFile(long offset, byte[] contenido) {
		try {
			fichero.seek(offset);
			fichero.write(contenido);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
//	public NFConnectorThread(Socket newSocket) {
//		socket = newSocket;
//	}
//	
	public void run() {
		respuestaFichero = nf.acordarFicherosDownload(localFileName);
		semaf.release();
		semaf.acquire();
		long offset = getOffset();
		while(offset < fichero_size) {
			nf.downloadChunk(fichero, offset, respuestaFichero.fileHash, respuestaFichero.fileSize);
			offset = getOffset();
		}
	}
	
}
